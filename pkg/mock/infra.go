// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/secmon-lab/alertchain/pkg/domain/interfaces"
	"github.com/secmon-lab/alertchain/pkg/domain/model"
	"github.com/secmon-lab/alertchain/pkg/domain/types"
	"sync"
	"time"
)

// Ensure, that GenAIMock does implement interfaces.GenAI.
// If this is not the case, regenerate this file with moq.
var _ interfaces.GenAI = &GenAIMock{}

// GenAIMock is a mock implementation of interfaces.GenAI.
//
//	func TestSomethingThatUsesGenAI(t *testing.T) {
//
//		// make and configure a mocked interfaces.GenAI
//		mockedGenAI := &GenAIMock{
//			GenerateFunc: func(ctx context.Context, prompts ...string) ([]string, error) {
//				panic("mock out the Generate method")
//			},
//		}
//
//		// use mockedGenAI in code that requires interfaces.GenAI
//		// and then make assertions.
//
//	}
type GenAIMock struct {
	// GenerateFunc mocks the Generate method.
	GenerateFunc func(ctx context.Context, prompts ...string) ([]string, error)

	// calls tracks calls to the methods.
	calls struct {
		// Generate holds details about calls to the Generate method.
		Generate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Prompts is the prompts argument value.
			Prompts []string
		}
	}
	lockGenerate sync.RWMutex
}

// Generate calls GenerateFunc.
func (mock *GenAIMock) Generate(ctx context.Context, prompts ...string) ([]string, error) {
	if mock.GenerateFunc == nil {
		panic("GenAIMock.GenerateFunc: method is nil but GenAI.Generate was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Prompts []string
	}{
		Ctx:     ctx,
		Prompts: prompts,
	}
	mock.lockGenerate.Lock()
	mock.calls.Generate = append(mock.calls.Generate, callInfo)
	mock.lockGenerate.Unlock()
	return mock.GenerateFunc(ctx, prompts...)
}

// GenerateCalls gets all the calls that were made to Generate.
// Check the length with:
//
//	len(mockedGenAI.GenerateCalls())
func (mock *GenAIMock) GenerateCalls() []struct {
	Ctx     context.Context
	Prompts []string
} {
	var calls []struct {
		Ctx     context.Context
		Prompts []string
	}
	mock.lockGenerate.RLock()
	calls = mock.calls.Generate
	mock.lockGenerate.RUnlock()
	return calls
}

// Ensure, that DatabaseMock does implement interfaces.Database.
// If this is not the case, regenerate this file with moq.
var _ interfaces.Database = &DatabaseMock{}

// DatabaseMock is a mock implementation of interfaces.Database.
//
//	func TestSomethingThatUsesDatabase(t *testing.T) {
//
//		// make and configure a mocked interfaces.Database
//		mockedDatabase := &DatabaseMock{
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			GetAlertFunc: func(ctx context.Context, id types.AlertID) (*model.Alert, error) {
//				panic("mock out the GetAlert method")
//			},
//			GetAttrsFunc: func(ctx context.Context, ns types.Namespace) (model.Attributes, error) {
//				panic("mock out the GetAttrs method")
//			},
//			GetWorkflowFunc: func(ctx context.Context, id types.WorkflowID) (*model.WorkflowRecord, error) {
//				panic("mock out the GetWorkflow method")
//			},
//			GetWorkflowsFunc: func(ctx context.Context, offset int, limit int) ([]model.WorkflowRecord, error) {
//				panic("mock out the GetWorkflows method")
//			},
//			LockFunc: func(ctx context.Context, ns types.Namespace, timeout time.Time) error {
//				panic("mock out the Lock method")
//			},
//			PutAlertFunc: func(ctx context.Context, alert model.Alert) error {
//				panic("mock out the PutAlert method")
//			},
//			PutAttrsFunc: func(ctx context.Context, ns types.Namespace, attrs model.Attributes) error {
//				panic("mock out the PutAttrs method")
//			},
//			PutWorkflowFunc: func(ctx context.Context, workflow model.WorkflowRecord) error {
//				panic("mock out the PutWorkflow method")
//			},
//			UnlockFunc: func(ctx context.Context, ns types.Namespace) error {
//				panic("mock out the Unlock method")
//			},
//		}
//
//		// use mockedDatabase in code that requires interfaces.Database
//		// and then make assertions.
//
//	}
type DatabaseMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// GetAlertFunc mocks the GetAlert method.
	GetAlertFunc func(ctx context.Context, id types.AlertID) (*model.Alert, error)

	// GetAttrsFunc mocks the GetAttrs method.
	GetAttrsFunc func(ctx context.Context, ns types.Namespace) (model.Attributes, error)

	// GetWorkflowFunc mocks the GetWorkflow method.
	GetWorkflowFunc func(ctx context.Context, id types.WorkflowID) (*model.WorkflowRecord, error)

	// GetWorkflowsFunc mocks the GetWorkflows method.
	GetWorkflowsFunc func(ctx context.Context, offset int, limit int) ([]model.WorkflowRecord, error)

	// LockFunc mocks the Lock method.
	LockFunc func(ctx context.Context, ns types.Namespace, timeout time.Time) error

	// PutAlertFunc mocks the PutAlert method.
	PutAlertFunc func(ctx context.Context, alert model.Alert) error

	// PutAttrsFunc mocks the PutAttrs method.
	PutAttrsFunc func(ctx context.Context, ns types.Namespace, attrs model.Attributes) error

	// PutWorkflowFunc mocks the PutWorkflow method.
	PutWorkflowFunc func(ctx context.Context, workflow model.WorkflowRecord) error

	// UnlockFunc mocks the Unlock method.
	UnlockFunc func(ctx context.Context, ns types.Namespace) error

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// GetAlert holds details about calls to the GetAlert method.
		GetAlert []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID types.AlertID
		}
		// GetAttrs holds details about calls to the GetAttrs method.
		GetAttrs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ns is the ns argument value.
			Ns types.Namespace
		}
		// GetWorkflow holds details about calls to the GetWorkflow method.
		GetWorkflow []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID types.WorkflowID
		}
		// GetWorkflows holds details about calls to the GetWorkflows method.
		GetWorkflows []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Offset is the offset argument value.
			Offset int
			// Limit is the limit argument value.
			Limit int
		}
		// Lock holds details about calls to the Lock method.
		Lock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ns is the ns argument value.
			Ns types.Namespace
			// Timeout is the timeout argument value.
			Timeout time.Time
		}
		// PutAlert holds details about calls to the PutAlert method.
		PutAlert []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Alert is the alert argument value.
			Alert model.Alert
		}
		// PutAttrs holds details about calls to the PutAttrs method.
		PutAttrs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ns is the ns argument value.
			Ns types.Namespace
			// Attrs is the attrs argument value.
			Attrs model.Attributes
		}
		// PutWorkflow holds details about calls to the PutWorkflow method.
		PutWorkflow []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Workflow is the workflow argument value.
			Workflow model.WorkflowRecord
		}
		// Unlock holds details about calls to the Unlock method.
		Unlock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ns is the ns argument value.
			Ns types.Namespace
		}
	}
	lockClose        sync.RWMutex
	lockGetAlert     sync.RWMutex
	lockGetAttrs     sync.RWMutex
	lockGetWorkflow  sync.RWMutex
	lockGetWorkflows sync.RWMutex
	lockLock         sync.RWMutex
	lockPutAlert     sync.RWMutex
	lockPutAttrs     sync.RWMutex
	lockPutWorkflow  sync.RWMutex
	lockUnlock       sync.RWMutex
}

// Close calls CloseFunc.
func (mock *DatabaseMock) Close() error {
	if mock.CloseFunc == nil {
		panic("DatabaseMock.CloseFunc: method is nil but Database.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedDatabase.CloseCalls())
func (mock *DatabaseMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// GetAlert calls GetAlertFunc.
func (mock *DatabaseMock) GetAlert(ctx context.Context, id types.AlertID) (*model.Alert, error) {
	if mock.GetAlertFunc == nil {
		panic("DatabaseMock.GetAlertFunc: method is nil but Database.GetAlert was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  types.AlertID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetAlert.Lock()
	mock.calls.GetAlert = append(mock.calls.GetAlert, callInfo)
	mock.lockGetAlert.Unlock()
	return mock.GetAlertFunc(ctx, id)
}

// GetAlertCalls gets all the calls that were made to GetAlert.
// Check the length with:
//
//	len(mockedDatabase.GetAlertCalls())
func (mock *DatabaseMock) GetAlertCalls() []struct {
	Ctx context.Context
	ID  types.AlertID
} {
	var calls []struct {
		Ctx context.Context
		ID  types.AlertID
	}
	mock.lockGetAlert.RLock()
	calls = mock.calls.GetAlert
	mock.lockGetAlert.RUnlock()
	return calls
}

// GetAttrs calls GetAttrsFunc.
func (mock *DatabaseMock) GetAttrs(ctx context.Context, ns types.Namespace) (model.Attributes, error) {
	if mock.GetAttrsFunc == nil {
		panic("DatabaseMock.GetAttrsFunc: method is nil but Database.GetAttrs was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Ns  types.Namespace
	}{
		Ctx: ctx,
		Ns:  ns,
	}
	mock.lockGetAttrs.Lock()
	mock.calls.GetAttrs = append(mock.calls.GetAttrs, callInfo)
	mock.lockGetAttrs.Unlock()
	return mock.GetAttrsFunc(ctx, ns)
}

// GetAttrsCalls gets all the calls that were made to GetAttrs.
// Check the length with:
//
//	len(mockedDatabase.GetAttrsCalls())
func (mock *DatabaseMock) GetAttrsCalls() []struct {
	Ctx context.Context
	Ns  types.Namespace
} {
	var calls []struct {
		Ctx context.Context
		Ns  types.Namespace
	}
	mock.lockGetAttrs.RLock()
	calls = mock.calls.GetAttrs
	mock.lockGetAttrs.RUnlock()
	return calls
}

// GetWorkflow calls GetWorkflowFunc.
func (mock *DatabaseMock) GetWorkflow(ctx context.Context, id types.WorkflowID) (*model.WorkflowRecord, error) {
	if mock.GetWorkflowFunc == nil {
		panic("DatabaseMock.GetWorkflowFunc: method is nil but Database.GetWorkflow was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  types.WorkflowID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetWorkflow.Lock()
	mock.calls.GetWorkflow = append(mock.calls.GetWorkflow, callInfo)
	mock.lockGetWorkflow.Unlock()
	return mock.GetWorkflowFunc(ctx, id)
}

// GetWorkflowCalls gets all the calls that were made to GetWorkflow.
// Check the length with:
//
//	len(mockedDatabase.GetWorkflowCalls())
func (mock *DatabaseMock) GetWorkflowCalls() []struct {
	Ctx context.Context
	ID  types.WorkflowID
} {
	var calls []struct {
		Ctx context.Context
		ID  types.WorkflowID
	}
	mock.lockGetWorkflow.RLock()
	calls = mock.calls.GetWorkflow
	mock.lockGetWorkflow.RUnlock()
	return calls
}

// GetWorkflows calls GetWorkflowsFunc.
func (mock *DatabaseMock) GetWorkflows(ctx context.Context, offset int, limit int) ([]model.WorkflowRecord, error) {
	if mock.GetWorkflowsFunc == nil {
		panic("DatabaseMock.GetWorkflowsFunc: method is nil but Database.GetWorkflows was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Offset int
		Limit  int
	}{
		Ctx:    ctx,
		Offset: offset,
		Limit:  limit,
	}
	mock.lockGetWorkflows.Lock()
	mock.calls.GetWorkflows = append(mock.calls.GetWorkflows, callInfo)
	mock.lockGetWorkflows.Unlock()
	return mock.GetWorkflowsFunc(ctx, offset, limit)
}

// GetWorkflowsCalls gets all the calls that were made to GetWorkflows.
// Check the length with:
//
//	len(mockedDatabase.GetWorkflowsCalls())
func (mock *DatabaseMock) GetWorkflowsCalls() []struct {
	Ctx    context.Context
	Offset int
	Limit  int
} {
	var calls []struct {
		Ctx    context.Context
		Offset int
		Limit  int
	}
	mock.lockGetWorkflows.RLock()
	calls = mock.calls.GetWorkflows
	mock.lockGetWorkflows.RUnlock()
	return calls
}

// Lock calls LockFunc.
func (mock *DatabaseMock) Lock(ctx context.Context, ns types.Namespace, timeout time.Time) error {
	if mock.LockFunc == nil {
		panic("DatabaseMock.LockFunc: method is nil but Database.Lock was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Ns      types.Namespace
		Timeout time.Time
	}{
		Ctx:     ctx,
		Ns:      ns,
		Timeout: timeout,
	}
	mock.lockLock.Lock()
	mock.calls.Lock = append(mock.calls.Lock, callInfo)
	mock.lockLock.Unlock()
	return mock.LockFunc(ctx, ns, timeout)
}

// LockCalls gets all the calls that were made to Lock.
// Check the length with:
//
//	len(mockedDatabase.LockCalls())
func (mock *DatabaseMock) LockCalls() []struct {
	Ctx     context.Context
	Ns      types.Namespace
	Timeout time.Time
} {
	var calls []struct {
		Ctx     context.Context
		Ns      types.Namespace
		Timeout time.Time
	}
	mock.lockLock.RLock()
	calls = mock.calls.Lock
	mock.lockLock.RUnlock()
	return calls
}

// PutAlert calls PutAlertFunc.
func (mock *DatabaseMock) PutAlert(ctx context.Context, alert model.Alert) error {
	if mock.PutAlertFunc == nil {
		panic("DatabaseMock.PutAlertFunc: method is nil but Database.PutAlert was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Alert model.Alert
	}{
		Ctx:   ctx,
		Alert: alert,
	}
	mock.lockPutAlert.Lock()
	mock.calls.PutAlert = append(mock.calls.PutAlert, callInfo)
	mock.lockPutAlert.Unlock()
	return mock.PutAlertFunc(ctx, alert)
}

// PutAlertCalls gets all the calls that were made to PutAlert.
// Check the length with:
//
//	len(mockedDatabase.PutAlertCalls())
func (mock *DatabaseMock) PutAlertCalls() []struct {
	Ctx   context.Context
	Alert model.Alert
} {
	var calls []struct {
		Ctx   context.Context
		Alert model.Alert
	}
	mock.lockPutAlert.RLock()
	calls = mock.calls.PutAlert
	mock.lockPutAlert.RUnlock()
	return calls
}

// PutAttrs calls PutAttrsFunc.
func (mock *DatabaseMock) PutAttrs(ctx context.Context, ns types.Namespace, attrs model.Attributes) error {
	if mock.PutAttrsFunc == nil {
		panic("DatabaseMock.PutAttrsFunc: method is nil but Database.PutAttrs was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Ns    types.Namespace
		Attrs model.Attributes
	}{
		Ctx:   ctx,
		Ns:    ns,
		Attrs: attrs,
	}
	mock.lockPutAttrs.Lock()
	mock.calls.PutAttrs = append(mock.calls.PutAttrs, callInfo)
	mock.lockPutAttrs.Unlock()
	return mock.PutAttrsFunc(ctx, ns, attrs)
}

// PutAttrsCalls gets all the calls that were made to PutAttrs.
// Check the length with:
//
//	len(mockedDatabase.PutAttrsCalls())
func (mock *DatabaseMock) PutAttrsCalls() []struct {
	Ctx   context.Context
	Ns    types.Namespace
	Attrs model.Attributes
} {
	var calls []struct {
		Ctx   context.Context
		Ns    types.Namespace
		Attrs model.Attributes
	}
	mock.lockPutAttrs.RLock()
	calls = mock.calls.PutAttrs
	mock.lockPutAttrs.RUnlock()
	return calls
}

// PutWorkflow calls PutWorkflowFunc.
func (mock *DatabaseMock) PutWorkflow(ctx context.Context, workflow model.WorkflowRecord) error {
	if mock.PutWorkflowFunc == nil {
		panic("DatabaseMock.PutWorkflowFunc: method is nil but Database.PutWorkflow was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Workflow model.WorkflowRecord
	}{
		Ctx:      ctx,
		Workflow: workflow,
	}
	mock.lockPutWorkflow.Lock()
	mock.calls.PutWorkflow = append(mock.calls.PutWorkflow, callInfo)
	mock.lockPutWorkflow.Unlock()
	return mock.PutWorkflowFunc(ctx, workflow)
}

// PutWorkflowCalls gets all the calls that were made to PutWorkflow.
// Check the length with:
//
//	len(mockedDatabase.PutWorkflowCalls())
func (mock *DatabaseMock) PutWorkflowCalls() []struct {
	Ctx      context.Context
	Workflow model.WorkflowRecord
} {
	var calls []struct {
		Ctx      context.Context
		Workflow model.WorkflowRecord
	}
	mock.lockPutWorkflow.RLock()
	calls = mock.calls.PutWorkflow
	mock.lockPutWorkflow.RUnlock()
	return calls
}

// Unlock calls UnlockFunc.
func (mock *DatabaseMock) Unlock(ctx context.Context, ns types.Namespace) error {
	if mock.UnlockFunc == nil {
		panic("DatabaseMock.UnlockFunc: method is nil but Database.Unlock was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Ns  types.Namespace
	}{
		Ctx: ctx,
		Ns:  ns,
	}
	mock.lockUnlock.Lock()
	mock.calls.Unlock = append(mock.calls.Unlock, callInfo)
	mock.lockUnlock.Unlock()
	return mock.UnlockFunc(ctx, ns)
}

// UnlockCalls gets all the calls that were made to Unlock.
// Check the length with:
//
//	len(mockedDatabase.UnlockCalls())
func (mock *DatabaseMock) UnlockCalls() []struct {
	Ctx context.Context
	Ns  types.Namespace
} {
	var calls []struct {
		Ctx context.Context
		Ns  types.Namespace
	}
	mock.lockUnlock.RLock()
	calls = mock.calls.Unlock
	mock.lockUnlock.RUnlock()
	return calls
}
